# Introduction to Docker

# Lecture summary: 
- What is a container and how to use it?
- How to create containers (namepaces, cgroups, layers)
- Docker architecture and commands
- Docker ecosystem
- Docker deep dive
- Docker build best practices
- Docker compose
- 12-factor app

# Recordings:
- [1/3](https://hwsw.adobeconnect.com/pmekyukviw7g/)
- [2/3](https://hwsw.adobeconnect.com/p85plkzjphum/)
- [3/3](https://hwsw.adobeconnect.com/p3dexxscwxvb/)

## Install Docker

The official documentaion on how to install Docker can be found here: https://docs.docker.com/get-docker/

On Windows and MAC you will install a desktop app which usually runs a Linux based virtual machine with Docker.

On Linux, you can install it by adding the `apt/yum` repository of Docker.
Alternatively, you can try this simple command: `curl -fsSL https://get.docker.com/ | sh`.
Also, on Ubuntu it be installed from the main repo by simply running `apt install docker.io`.

For a simple temporary test environment you can use Katacoda: https://www.katacoda.com/courses/docker/playground

## First containers

There are many public Docker image repositories, but Docker Hub is the most populer.
Visit https://hub.docker.com/ to search for applications.
You can search repository from the CLI as well:
```
docker search nginx
```

There are many `nginx` Docker images in the repository but there is only one official, so let's that one:
```
docker run nginx
```

First, you should see that the Docker Engine pull the image from the repository, and then starts it blocking the console.
If you hit `Ctlr+c` the container will stop.
You can check it by thus command that lists all running containers:
```
docker ps
```

You can see all the containers (including the stopped ones) with the `-a` parameter:
```
docker ps -a
```

My output was:
```
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                     PORTS               NAMES
fe4b8b305a23        nginx               "/docker-entrypoint.…"   3 minutes ago       Exited (0) 2 minutes ago                       stoic_ramanujan
```

You can see that the container exited with `Status Code: 0`.

You can restart the container by running `docker start <Container ID>`, but you only have to write the frist few characters of the ID, which makes it unique, e.g.:
```
docker start fe4  
```

You can see, that this way the console is not blocked, since default option of `docker start` is to run the container in daemon mode in the background.
You can also achive this during the `run` command with the `-d` parameter, it will print out the container ID, and exit:
```
docker run -d nginx
```

Check that now you have two `nginx` containers running with `docker ps`:
```
$ docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
2bf787a41381        nginx               "/docker-entrypoint.…"   54 seconds ago      Up 51 seconds       80/tcp              gallant_varahamihira
fe4b8b305a23        nginx               "/docker-entrypoint.…"   9 minutes ago       Up 4 minutes        80/tcp              stoic_ramanujan
```

If you want to see the logs generated by the container, run:
```
docker logs <container id>
```

You can also give friendly names to your containers with `--name <name>`, so you don't have to use the ID-s. All of the command that needs a continer ID will accept a name insted:
```
$ docker run -d --name myNginx nginx
91a610590fe58b4f16befc9690806ab9ae0df0a63e68cc9823626095ea607539
$ docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS               NAMES
91a610590fe5        nginx               "/docker-entrypoint.…"   3 seconds ago        Up 2 seconds        80/tcp              myNginx
2bf787a41381        nginx               "/docker-entrypoint.…"   3 minutes ago        Up 3 minutes        80/tcp              gallant_varahamihira
fe4b8b305a23        nginx               "/docker-entrypoint.…"   12 minutes ago       Up 7 minutes        80/tcp              stoic_ramanujan
```

You can now open a shell to the container with the following command:
```
docker exec -it myNginx bash
```

You can see that the webserver is running:
```
curl 127.0.0.1
```

The index page that you get is located here:
```
cat /usr/share/nginx/html/index.html
```

You can try to modify the file, and see the result:
```
echo "Hello HWSW Kubernetes Course" > /usr/share/nginx/html/index.html 
curl 127.0.0.1
```

Exit the container with simple `exit` command, or by `Ctrl-d`.


## Access you container from the outside

You can see all the information about your container with `docker inspect <friendly-name|container-id>`, the result will be a large `json` file:
```
docker inspect myNginx
```

At the end of the file you should see the IP address of the container:
```
            "Networks": {
                "bridge": {
                    "IPAMConfig": null,
                    "Links": null,
                    "Aliases": null,
                    "NetworkID": "b9f19564df74a6b6826fb2e5d08f2301874edd8d9ec99a9152c354f7943a9229",
                    "EndpointID": "07bebb44362e3efcc0206457b80f38500e7b8d71f517647798683d18953feff3",
                    "Gateway": "172.18.0.1",
                    "IPAddress": "172.18.0.4",
                    "IPPrefixLen": 24,
                    "IPv6Gateway": "",
                    "GlobalIPv6Address": "",
                    "GlobalIPv6PrefixLen": 0,
                    "MacAddress": "02:42:ac:12:00:05",
                    "DriverOpts": null
                }
```

Try to access the IP address with `curl`, e.g.:
```
curl 172.18.0.4
```

If a container needs to be accessible by a process not running in the host, then the port needs to be exposed via the Host.
Once exposed, it is possible to access the process as if it were running on the host OS itself. Try:
```
docker run -d --name nginxHostPort -p 8080:80 nginx
docker ps
curl 127.0.0.1:8080
```
Tip: by default, the port on the host is mapped to `0.0.0.0`, which means all IP addresses. You can specify a particular IP address when you define the port mapping, for example, `-p 127.0.0.1:8080:80`.

You also skip the local port definition, and Docker will choose a random free port for it (usually starting from 32768):
```
docker run -d --name nginxDynamic -p 80 nginx
docker ps
curl 127.0.0.1:32768
```

## Data persistence

Containers are designed to be stateless. When a container dies, all data is lost with it, unless it is saved to a `volume`.
Binding volumes (directories) is done using the option -v <host-dir>:<container-dir>. When a directory is mounted, the files which exist in that directory on the host can be accessed by the container and any data changed/written to the directory inside the container will be stored on the host. This allows you to upgrade or change containers without losing your data.

Open a shell to the `nginx` container and modify the `index.html` file in `/usr/share/nginx/html/index.html`:
```
docker exec -it myNginx bash
curl 127.0.0.1
echo "Hello HWSW Kubernetes Course" > /usr/share/nginx/html/index.html 
curl 127.0.0.1
```

Exit the container, delete it and start the same:
```
docker stop myNginx
docker rm myNginx
docker run -d --name myNginx nginx
```

If you `curl` it you will see that you modifications are lost, and the index file is restored to the default one.
```
curl 172.17.0.5
```

If you use volume your data should be persisted to the host machine:
```
docker run -d --name nginxMapped -v /tmp/nginx:/usr/share/nginx/html nginx
```
Tip: Docker allows you to use `$PWD` as a placeholder for the current directory.

If you access this container you sould see a `403` error:
```
root@docker-test:~# curl 172.17.0.6
<html>
<head><title>403 Forbidden</title></head>
<body>
<center><h1>403 Forbidden</h1></center>
<hr><center>nginx/1.19.2</center>
</body>
</html>
```

This is caused by the UnionFS when you use volume mounts: the directory from the host container will overwrite the original directory in the container image.
So if you create a file now on the host, you should see the result in the webserver:
```
echo "Hello HWSW Kubernetes Course" > /tmp/nginx/index.html 
curl 172.17.0.6
```

## Building container images

For building you own Docker image, you need a `Dockerfile`.
Check out the full documentaion what can be done in a `Dockerfile` here: https://docs.docker.com/engine/reference/builder/

The this simple example for an applications: https://github.com/Megzo/go-web-example/blob/master/webserver.go
If I wanted to build this app and run it on an Ubuntu machine, I should execute this steps:
```
mkdir go-web-example; cd go-web-example
# downloading the source
curl https://raw.githubusercontent.com/Megzo/go-web-example/master/webserver.go > webserver.go
# install the Golang SDK
apt install -y golang
go version
# build the application
go build .
ls -lh
# run the server
./go-web-example
```

So let's try to build the same app with Docker.
Create a `Dockerfile` with the following content:
```
FROM ubuntu:18.04
RUN apt-get update && apt-get install -y golang
WORKDIR /go-web-example
COPY webserver.go .
RUN go build .
EXPOSE 8000
ENV VERSION=1.0
ENTRYPOINT ["./go-web-example"]
```

Now build it and check the result:
```
docker build .
docker images
```

You can see that you image has no name, so lets give it one:
```
docker build -t webserver .
docker images
```

So let's start the Docker images:
```
docker run -d --name myGoWebserver webserver
docker ps
docker inspect myGoWebserver | tail -20
```

## Image sizes

When you run `docker images` you will see that the created image has 572MB size, whereas the `ubuntu:18.04` base image is just 62MB and the application binary is 7MB.
You can run `docker history webserver` to see the size of the layers:
```
root@docker-test:~/go-web-example# docker history webserver
IMAGE               CREATED              CREATED BY                                      SIZE                COMMENT
c3871cd6edb0        About a minute ago   /bin/sh -c #(nop)  ENTRYPOINT ["./go-web-exa…   0B                  
1e7f240022be        About a minute ago   /bin/sh -c #(nop)  ENV VERSION=1.0              0B                  
96f7e3842919        About a minute ago   /bin/sh -c #(nop)  EXPOSE 8000                  0B                  
ca161c22ce48        4 minutes ago        /bin/sh -c go build .                           6.65MB              
3800cd97b314        4 minutes ago        /bin/sh -c #(nop) COPY file:c65ba4472a0c23f6…   651B                
e2ed4e848276        4 minutes ago        /bin/sh -c #(nop) WORKDIR /go-web-example       0B                  
8c45e3445d89        15 minutes ago       /bin/sh -c apt-get update && apt-get install…   502MB               
c14bccfdea1c        14 hours ago         /bin/sh -c #(nop)  CMD ["/bin/bash"]            0B                  
<missing>           14 hours ago         /bin/sh -c mkdir -p /run/systemd && echo 'do…   7B                  
<missing>           14 hours ago         /bin/sh -c [ -z "$(apt-get indextargets)" ]     0B                  
<missing>           14 hours ago         /bin/sh -c set -xe   && echo '#!/bin/sh' > /…   745B                
<missing>           14 hours ago         /bin/sh -c #(nop) ADD file:84f8ddc4d76e1e867…   63.2MB
```

You can see that installing the `golang` SDK increased the image size with 502MB. The interesting thing is that we do not need the `golnag` SDK to run this binary, we just need it 
to build the application.
So one thing we can do is just simply copy the binary that was built on the host and run that inside of the container.
First, tag the previous image with e.g. this command: `docker build -t webserver:1.0 .`

Now change you `Dockerfile` to this:
```
FROM ubuntu:18.04
COPY go-web-example .
EXPOSE 8000
ENV VERSION=2.0
ENTRYPOINT ["./go-web-example"]
```

And build this new image:
```
docker build -t webserver:2.0 .
docker images
```

You can see that the new image is just ~70MB large (which is exactly the size of the `ubuntu:18.04` image and the binary itself).
And it runs the same:
```
docker run -d --name myGoWebserver2 webserver:2.0
docker ps
docker inspect myGoWebserver2 | tail -20
```

But wait, you don't actually need Ubuntu to run this binary, you can use a smaller base image, e.g. Alpine Linux.
(Note: since this binary is a static Go executable, it could even run in an `scratch` image, which is basically empty)

So let's use this `Dockerfile` now:
```
FROM alpine:3.12
COPY go-web-example .
EXPOSE 8000
ENV VERSION=3.0
ENTRYPOINT ["./go-web-example"]
```

And build this new image:
```
docker build -t webserver:3.0 .
docker images
```

## Multistage builds

In the previous examples we showed that you do not actually need a complier to run your application, and excluding it can save you a lot of space.
However, building in a local server and copy the executable to a container might to not be as reliable as you think.
But fortunately, Docker multistage builds helps you in this case, since it allows you to use one Docker image to build you app, and copy the executable from there to a final 
image that will be used to run the application.

A multistage `Dockerfile` would look like this:
```
FROM golang:1.15.2-alpine3.12 as buildimage
WORKDIR /src/webserver
COPY webserver.go ./
RUN go build -o /go-web-example -v webserver.go

FROM alpine:3.12
COPY  --from=buildimage /go-web-example .
EXPOSE 8000
ENV VERSION=4.0
ENTRYPOINT ["./go-web-example"]
```

And build this new image:
```
docker build -t webserver:4.0 .
docker images
```

Advices for Docker build:
 - Try to use multistage builds, since it will describe very clearly how your application should be built
 - Use languge specific build and run containers
 - Use Alipne when it's possible instead of Ubuntu/Debian/CentOS/etc.
 - When you become very pro in container debuging, use a distroless image: https://github.com/GoogleContainerTools/distroless

## Docker-compose

Many times your application includes more containers, e.g. an app server and database server.
We can use `docker-compose` to create such multi-container environmet.

To install `docker-compose` on Linux run:
```
apt install docker-compose
```
(Docker Desktop includes it by default)


Now we will create a `python-flask` application which uses `redis` as a cache:
```
cd
mkdir composetest
cd composetest
nano app.py
```

Copy the following content to `app.py`:
```
import time

import redis
from flask import Flask

app = Flask(__name__)
cache = redis.Redis(host='redis', port=6379)


def get_hit_count():
    retries = 5
    while True:
        try:
            return cache.incr('hits')
        except redis.exceptions.ConnectionError as exc:
            if retries == 0:
                raise exc
            retries -= 1
            time.sleep(0.5)


@app.route('/')
def hello():
    count = get_hit_count()
    return 'Hello HWSW Kubernetes! You are visitor: {}.\n'.format(count)
```

Create a file called `requirements.txt` and copy the following lines:
```
flask
redis
```

Create a `Dockerfile` with the following content:
```
FROM python:3.7-alpine
WORKDIR /code
ENV FLASK_APP app.py
ENV FLASK_RUN_HOST 0.0.0.0
RUN apk add --no-cache gcc musl-dev linux-headers
COPY requirements.txt requirements.txt
RUN pip install -r requirements.txt
EXPOSE 5000
COPY . .
CMD ["flask", "run"]
```

Now create `docker-compose.yml` file, which is used by Docker-Compose:
```
version: '3'
services:
  web:
    build: .
    ports:
      - "5000:5000"
    depends_on:
    - redis
  redis:
    image: "redis:alpine"
```

You can build and run your application:
```
docker-compose up -d
docker-compose logs
docker-compose ps
```

Clear you environment
```
docker-compose stop
docker-compose rm
```

## Extra: Namespaces for container separation

```
docker run -it --name ubi ubuntu /bin/bash
# in separate terminal check container processes
docker exec ubi /bin/bash -c "ps aux"
# check host processes, notice PROCESS-ID
ps aux | grep /bin/bash
# check namespaces for that process 
ll /proc/<PROCESS-ID>/ns/
# checking network interfaces 
apt update && apt install -y iproute2
ip a
# checking disk in the filesystems
docker exec ubi df
df
```
